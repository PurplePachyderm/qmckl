#+TITLE: Electrons
#+SETUPFILE: ../tools/theme.setup
#+INCLUDE: ../tools/lib.org

In conventional QMC simulations, up-spin and down-spin electrons are
different. The ~electron~  data structure contains the number of
up-spin and down-spin electrons, and the electron coordinates.

* Headers                                                          :noexport:
  #+begin_src elisp :noexport :results none
(org-babel-lob-ingest "../tools/lib.org")
#+end_src


  #+begin_src c :tangle (eval h_private_type)
#ifndef QMCKL_ELECTRON_HPT
#define QMCKL_ELECTRON_HPT
#include <stdbool.h>
  #+end_src

  #+begin_src c :tangle (eval c_test) :noweb yes
#include "qmckl.h"
#include <assert.h>
#include <math.h>
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_VERIFICARLO
#include <vfc_probes.h>
#endif

#include "chbrclf.h"

int main() {
  qmckl_context context;
  context = qmckl_context_create();
  vfc_probes probes = vfc_init_probes();
  #+end_src

  #+begin_src c :tangle (eval c)
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
#elif HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h>

#include <stdio.h>

#include "qmckl.h"
#include "qmckl_context_private_type.h"
#include "qmckl_memory_private_type.h"
#include "qmckl_memory_private_func.h"
#include "qmckl_electron_private_func.h"
  #+end_src

* Context

  The following data stored in the context:

   | ~uninitialized~    | int32_t                         | Keeps bit set for uninitialized data                      |
   | ~num~              | int64_t                         | Total number of electrons                                 |
   | ~up_num~           | int64_t                         | Number of up-spin electrons                               |
   | ~down_num~         | int64_t                         | Number of down-spin electrons                             |
   | ~walk_num~         | int64_t                         | Number of walkers                                         |
   | ~provided~         | bool                            | If true, ~electron~ is valid                              |
   | ~coord_new~        | double[walk_num][3][num]        | New set of electron coordinates                           |
   | ~coord_old~        | double[walk_num][3][num]        | Old set of electron coordinates                           |
   | ~coord_new_date~   | uint64_t                        | Last modification date of the coordinates                 |
   | ~ee_distance~      | double[walk_num][num][num]      | Electron-electron distances                               |
   | ~ee_distance_date~ | uint64_t                        | Last modification date of the electron-electron distances |
   | ~en_distance~      | double[walk_num][nucl_num][num] | Electron-nucleus distances                                |
   | ~en_distance_date~ | uint64_t                        | Last modification date of the electron-electron distances |

** Data structure

   #+begin_src c :comments org :tangle (eval h_private_type)
typedef struct qmckl_electron_struct {
  int64_t   num;
  int64_t   up_num;
  int64_t   down_num;
  int64_t   walk_num;
  int64_t   coord_new_date;
  int64_t   ee_distance_date;
  int64_t   en_distance_date;
  double*   coord_new;
  double*   coord_old;
  double*   ee_distance;
  double*   en_distance;
  int32_t   uninitialized;
  bool      provided;
} qmckl_electron_struct;
   #+end_src

   The ~uninitialized~ integer contains one bit set to one for each
   initialization function which has not bee called. It becomes equal
   to zero after all initialization functions have been called. The
   struct is then initialized and ~provided == true~.

   When all the data relative to electrons have been set, the
   following function returns ~true~.

      #+begin_src c :comments org :tangle (eval h_func)
bool qmckl_electron_provided (const qmckl_context context);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
bool qmckl_electron_provided(const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  return ctx->electron.provided;
}
      #+end_src

** Access functions

   Access functions return ~QMCKL_SUCCESS~ when the data has been
   successfully retrieved. It returnes ~QMCKL_INVALID_CONTEXT~ when
   the context is not a valid context, and ~QMCKL_NOT_PROVIDED~ when
   the data has not been provided. If the function returns
   successfully, the variable pointed by the pointer given in argument
   contains the requested data. Otherwise, this variable is untouched.

      #+NAME:post
      #+begin_src c  :exports none
if ( (ctx->electron.uninitialized & mask) != 0) {
  return NULL;
}
      #+end_src

*** Number of electrons

      #+begin_src c :comments org :tangle (eval h_func) :exports none
qmckl_exit_code qmckl_get_electron_num        (const qmckl_context context, int64_t* const num);
qmckl_exit_code qmckl_get_electron_up_num     (const qmckl_context context, int64_t* const up_num);
qmckl_exit_code qmckl_get_electron_down_num   (const qmckl_context context, int64_t* const down_num);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_get_electron_num (const qmckl_context context, int64_t* const num) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_num",
                           "num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.num > (int64_t) 0);
  ,*num = ctx->electron.num;
  return QMCKL_SUCCESS;
}


qmckl_exit_code
qmckl_get_electron_up_num (const qmckl_context context, int64_t* const up_num) {
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (up_num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_up_num",
                           "up_num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.up_num > (int64_t) 0);
  ,*up_num = ctx->electron.up_num;
  return QMCKL_SUCCESS;
}


qmckl_exit_code
qmckl_get_electron_down_num (const qmckl_context context, int64_t* const down_num) {
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (down_num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_down_num",
                           "down_num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.down_num >= (int64_t) 0);
  ,*down_num = ctx->electron.down_num;
  return QMCKL_SUCCESS;
}

      #+end_src

*** Number of walkers

    A walker is a set of electron coordinates that are arguments of
    the wave function. ~walk_num~ is the number of walkers.

      #+begin_src c :comments org :tangle (eval h_func) :exports none
qmckl_exit_code qmckl_get_electron_walk_num   (const qmckl_context context, int64_t* const walk_num);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_get_electron_walk_num (const qmckl_context context, int64_t* const walk_num) {
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (walk_num == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_walk_num",
                           "walk_num is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 2;

  if ( (ctx->electron.uninitialized & mask) != 0) {
    return QMCKL_NOT_PROVIDED;
  }

  assert (ctx->electron.walk_num > (int64_t) 0);
  ,*walk_num = ctx->electron.walk_num;
  return QMCKL_SUCCESS;
}
      #+end_src

*** Electron coordinates

    Returns the current electron coordinates. The pointer is assumed
    to point on a memory block of size ~3 * elec_num * walk_num~. 
    The order of the indices is:

    |         | Normal                    | Transposed                |
    |---------+---------------------------+---------------------------|
    | C       | ~[walk_num][elec_num][3]~ | ~[walk_num][3][elec_num]~ |
    | Fortran | ~(3,elec_num,walk_num)~   | ~(elec_num,3,walk_num)~   |


      #+begin_src c :comments org :tangle (eval h_func) :exports none
qmckl_exit_code qmckl_get_electron_coord (const qmckl_context context, const char transp, double* const coord);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_get_electron_coord (const qmckl_context context, const char transp, double* const coord) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_INVALID_CONTEXT;
  }

  if (transp != 'N' && transp != 'T') {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_get_electron_coord",
                           "transp should be 'N' or 'T'");
  }

  if (coord == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_get_electron_coord",
                           "coord is a null pointer");
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  if ( !(ctx->electron.provided) ) {
    return qmckl_failwith( context,
                           QMCKL_NOT_PROVIDED,
                           "qmckl_get_electron_coord",
                           "electron data is not provided");
  }

  int64_t elec_num = ctx->electron.num;
  int64_t walk_num = ctx->electron.walk_num;

  assert (ctx->electron.coord_new != NULL);

  double* ptr1 = ctx->electron.coord_new;
  double* ptr2 = coord;

  if (transp == 'N') {

    for (int64_t i=0 ; i<walk_num ; ++i) {
      qmckl_exit_code rc;
      rc = qmckl_transpose(context, elec_num, 3,
                           ptr1, elec_num, ptr2, 3);
      if (rc != QMCKL_SUCCESS) return rc;
      ptr1 += elec_num * 3;
      ptr2 += elec_num * 3;
    }

  } else {

    memcpy(ptr2, ptr1, 3*elec_num*walk_num*sizeof(double));

  }
  
  return QMCKL_SUCCESS;
}

      #+end_src

** Initialization functions

   To set the data relative to the electrons in the context, the
   following functions need to be called. When the data structure is
   initialized, the internal ~coord_new~ and ~coord_old~ arrays are
   both allocated.

   #+begin_src c :comments org :tangle (eval h_func)
qmckl_exit_code  qmckl_set_electron_num        (qmckl_context context, const int64_t up_num, const int64_t down_num);
qmckl_exit_code  qmckl_set_electron_walk_num   (qmckl_context context, const int64_t walk_num);
qmckl_exit_code  qmckl_set_electron_coord      (qmckl_context context, const char transp, const double* coord);
   #+end_src

   #+NAME:pre2
   #+begin_src c :exports none
if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  return QMCKL_NULL_CONTEXT;
 }

qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
   #+end_src

   #+NAME:post2
   #+begin_src c :exports none
ctx->electron.uninitialized &= ~mask;
ctx->electron.provided = (ctx->electron.uninitialized == 0);

if (ctx->electron.provided) {
  if (ctx->electron.coord_new != NULL) {
    qmckl_free(context, ctx->electron.coord_new);
    ctx->electron.coord_new = NULL;
  }
  if (ctx->electron.coord_old != NULL) {
    qmckl_free(context, ctx->electron.coord_old);
    ctx->electron.coord_old = NULL;
  }

  qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  mem_info.size = ctx->electron.num * ctx->electron.walk_num * 3 * sizeof(double);

  double* coord_new = (double*) qmckl_malloc(context, mem_info);
  if (coord_new == NULL) {
    return qmckl_failwith( context,
                           QMCKL_ALLOCATION_FAILED,
                           "qmckl_set_electron_num",
                           NULL);
  }
  ctx->electron.coord_new = coord_new;

  double* coord_old = (double*) qmckl_malloc(context, mem_info);
  if (coord_old == NULL) {
    return qmckl_failwith( context,
                           QMCKL_ALLOCATION_FAILED,
                           "qmckl_set_electron_num",
                           NULL);
  }
  ctx->electron.coord_old = coord_old;

 }

return QMCKL_SUCCESS;
   #+end_src

   To set the number of electrons, we give the number of up-spin and
   down-spin electrons to the context and we set the number of walkers.

   #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code
qmckl_set_electron_num(qmckl_context context,
                       const int64_t up_num,
                       const int64_t down_num) {
  <<pre2>>

  if (up_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_electron_num",
                           "up_num <= 0");
  }

  if (down_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_set_electron_num",
                           "down_num <= 0");
  }

  int32_t mask = 1;

  ctx->electron.up_num = up_num;
  ctx->electron.down_num = down_num;
  ctx->electron.num = up_num + down_num;

  <<post2>>
}
   #+end_src


   #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_set_electron_walk_num(qmckl_context context, const int64_t walk_num) {

  <<pre2>>

  if (walk_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_electron_walk_num",
                           "walk_num <= 0");
  }

  int32_t mask = 2;
  ctx->electron.walk_num = walk_num;

  <<post2>>
}
    #+end_src

    The following function sets the electron coordinates of all the
    walkers. When this is done, the pointers to the old and new sets
    of coordinates are swapped, and the new coordinates are
    overwritten. This can be done only when the data relative to
    electrons have been set.

    Important: changing the electron coordinates increments the date
    in the context.

   #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code
qmckl_set_electron_coord(qmckl_context context, const char transp, const double* coord) {

  <<pre2>>

  if (transp != 'N' && transp != 'T') {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_electron_coord",
                           "transp should be 'N' or 'T'");
  }

  if (coord == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_3,
                           "qmckl_set_electron_coord",
                           "coord is a null pointer");
  }

  int64_t elec_num;
  qmckl_exit_code rc;
  rc = qmckl_get_electron_num(context, &elec_num);
  if (rc != QMCKL_SUCCESS) return rc;

  if (elec_num == 0L) {
    return qmckl_failwith( context,
                           QMCKL_FAILURE,
                           "qmckl_set_electron_coord",
                           "elec_num is not set");
  }

  int64_t walk_num;
  rc = qmckl_get_electron_walk_num(context, &walk_num);
  if (rc != QMCKL_SUCCESS) return rc;

  if (walk_num == 0L) {
    return qmckl_failwith( context,
                           QMCKL_FAILURE,
                           "qmckl_set_electron_coord",
                           "walk_num is not set");
  }

  /* If num and walk_num are set, the arrays should be allocated */
  assert (ctx->electron.coord_old != NULL);
  assert (ctx->electron.coord_new != NULL);

  /* Increment the date of the context */
  ctx->date += 1UL;

  /* Swap pointers */
  double * swap;
  swap = ctx->electron.coord_old;
  ctx->electron.coord_old = ctx->electron.coord_new;
  ctx->electron.coord_new = swap;

  double* ptr1 = ctx->electron.coord_new;
  if (transp == 'N') {

    for (int64_t i=0 ; i<walk_num ; ++i) {
      rc = qmckl_transpose(context, 3, elec_num,
                           &(coord[i*3*elec_num]), 3, ptr1, elec_num);
      if (rc != QMCKL_SUCCESS) return rc;
      ptr1 += elec_num * 3;
    }
    
  } else {

    memcpy(ptr1, coord, 3*elec_num*walk_num*sizeof(double));

  }
  ctx->electron.coord_new_date = ctx->date;

  return QMCKL_SUCCESS;

}
   #+end_src

** Test

   #+begin_src python :results output :exports none
import numpy as np

   #+end_src

   #+begin_src c :tangle (eval c_test)
/* Reference input data */
int64_t walk_num      = chbrclf_walk_num;
int64_t elec_num      = chbrclf_elec_num;
int64_t elec_up_num   = chbrclf_elec_up_num;
int64_t elec_dn_num   = chbrclf_elec_dn_num;
double* elec_coord    = &(chbrclf_elec_coord[0][0][0]);

int64_t  nucl_num      = chbrclf_nucl_num;
double*  charge        = chbrclf_charge;
double*  nucl_coord    = &(chbrclf_nucl_coord[0][0]);

/* --- */

qmckl_exit_code rc;

assert(!qmckl_electron_provided(context));

int64_t n;
rc = qmckl_get_electron_num (context, &n);
assert(rc == QMCKL_NOT_PROVIDED);

rc = qmckl_get_electron_up_num (context, &n);
assert(rc == QMCKL_NOT_PROVIDED);

rc = qmckl_get_electron_down_num (context, &n);
assert(rc == QMCKL_NOT_PROVIDED);


rc = qmckl_set_electron_num (context, elec_up_num, elec_dn_num);
assert(rc == QMCKL_SUCCESS);
assert(!qmckl_electron_provided(context));

rc = qmckl_get_electron_up_num (context, &n);
assert(rc == QMCKL_SUCCESS);
assert(n == elec_up_num);

rc = qmckl_get_electron_down_num (context, &n);
assert(rc == QMCKL_SUCCESS);
assert(n == elec_dn_num);

rc = qmckl_get_electron_num (context, &n);
assert(rc == QMCKL_SUCCESS);
assert(n == elec_num);


int64_t w;
rc = qmckl_get_electron_walk_num (context, &w);
assert(rc == QMCKL_NOT_PROVIDED);


rc = qmckl_set_electron_walk_num (context, walk_num);
assert(rc == QMCKL_SUCCESS);

rc = qmckl_get_electron_walk_num (context, &w);
assert(rc == QMCKL_SUCCESS);
assert(w == walk_num);

assert(qmckl_electron_provided(context));

rc = qmckl_set_electron_coord (context, 'N', elec_coord);
assert(rc == QMCKL_SUCCESS);

double elec_coord2[walk_num*3*elec_num];

rc = qmckl_get_electron_coord (context, 'N', elec_coord2);
assert(rc == QMCKL_SUCCESS);
for (int64_t i=0 ; i<3*elec_num ; ++i) {
  assert( elec_coord[i] == elec_coord2[i] );
 }

    #+end_src

* Computation

  The computed data is stored in the context so that it can be reused
  by different kernels. To ensure that the data is valid, for each
  computed data the date of the context is stored when it is computed.
  To know if some data needs to be recomputed, we check if the date of
  the dependencies are more recent than the date of the data to
  compute. If it is the case, then the data is recomputed and the
  current date is stored.

** Electron-electron distances

*** Get

    #+begin_src c :comments org :tangle (eval h_func) :noweb yes
qmckl_exit_code qmckl_get_electron_ee_distance(qmckl_context context, double* const distance);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_get_electron_ee_distance(qmckl_context context, double* const distance)
{
  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_exit_code rc;

  rc = qmckl_provide_ee_distance(context);
  if (rc != QMCKL_SUCCESS) return rc;

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  size_t sze = ctx->electron.num * ctx->electron.num * ctx->electron.walk_num;
  memcpy(distance, ctx->electron.ee_distance, sze * sizeof(double));

  return QMCKL_SUCCESS;
}
    #+end_src

*** Provide                                                        :noexport:

    #+begin_src c :comments org :tangle (eval h_private_func) :noweb yes :exports none
qmckl_exit_code qmckl_provide_ee_distance(qmckl_context context);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_provide_ee_distance(qmckl_context context)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);


  /* Compute if necessary */
  if (ctx->electron.coord_new_date > ctx->electron.ee_distance_date) {

    /* Allocate array */
    if (ctx->electron.ee_distance == NULL) {

      qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
      mem_info.size = ctx->electron.num * ctx->electron.num *
        ctx->electron.walk_num * sizeof(double);
      double* ee_distance = (double*) qmckl_malloc(context, mem_info);

      if (ee_distance == NULL) {
        return qmckl_failwith( context,
                               QMCKL_ALLOCATION_FAILED,
                               "qmckl_ee_distance",
                               NULL);
      }
      ctx->electron.ee_distance = ee_distance;
    }

    qmckl_exit_code rc =
      qmckl_compute_ee_distance(context,
                                ctx->electron.num,
                                ctx->electron.walk_num,
                                ctx->electron.coord_new,
                                ctx->electron.ee_distance);
    if (rc != QMCKL_SUCCESS) {
      return rc;
    }

    ctx->electron.ee_distance_date = ctx->date;
  }

  return QMCKL_SUCCESS;
}
    #+end_src

*** Compute
   :PROPERTIES:
   :Name:     qmckl_compute_ee_distance
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

    #+NAME: qmckl_ee_distance_args
   | qmckl_context | context                                   | in  | Global state                |
   | int64_t       | elec_num                                  | in  | Number of electrons         |
   | int64_t       | walk_num                                  | in  | Number of walkers           |
   | double        | coord[walk_num][3][elec_num]              | in  | Electron coordinates        |
   | double        | ee_distance[walk_num][elec_num][elec_num] | out | Electron-electron distances |

    #+begin_src f90 :comments org :tangle (eval f) :noweb yes
integer function qmckl_compute_ee_distance_f(context, elec_num, walk_num, coord, ee_distance) &
     result(info)
  use qmckl
  implicit none
  integer(qmckl_context), intent(in)  :: context
  integer*8             , intent(in)  :: elec_num
  integer*8             , intent(in)  :: walk_num
  double precision      , intent(in)  :: coord(elec_num,3,walk_num)
  double precision      , intent(out) :: ee_distance(elec_num,elec_num,walk_num)

  integer*8 :: k

  info = QMCKL_SUCCESS

  if (context == QMCKL_NULL_CONTEXT) then
     info = QMCKL_INVALID_CONTEXT
     return
  endif

  if (elec_num <= 0) then
     info = QMCKL_INVALID_ARG_2
     return
  endif

  if (walk_num <= 0) then
     info = QMCKL_INVALID_ARG_3
     return
  endif

  do k=1,walk_num
     info = qmckl_distance(context, 'T', 'T', elec_num, elec_num, &
          coord(1,1,k), elec_num, &
          coord(1,1,k), elec_num, &
          ee_distance(1,1,k), elec_num)
     if (info /= QMCKL_SUCCESS) then
        exit
     endif
  end do

end function qmckl_compute_ee_distance_f
    #+end_src

    #+begin_src c :tangle (eval h_private_func) :comments org :exports none
qmckl_exit_code qmckl_compute_ee_distance (
          const qmckl_context context,
          const int64_t elec_num,
          const int64_t walk_num,
          const double* coord,
          double* const ee_distance );
    #+end_src

    #+CALL: generate_c_interface(table=qmckl_ee_distance_args,rettyp=get_value("CRetType"),fname=get_value("Name"))

    #+RESULTS:
    #+begin_src f90 :tangle (eval f) :comments org :exports none
    integer(c_int32_t) function qmckl_compute_ee_distance &
        (context, elec_num, walk_num, coord, ee_distance) &
        bind(C) result(info)

      use, intrinsic :: iso_c_binding
      implicit none

      integer (c_int64_t) , intent(in)  , value :: context
      integer (c_int64_t) , intent(in)  , value :: elec_num
      integer (c_int64_t) , intent(in)  , value :: walk_num
      real    (c_double ) , intent(in)          :: coord(elec_num,3,walk_num)
      real    (c_double ) , intent(out)         :: ee_distance(elec_num,elec_num,walk_num)

      integer(c_int32_t), external :: qmckl_compute_ee_distance_f
      info = qmckl_compute_ee_distance_f &
             (context, elec_num, walk_num, coord, ee_distance)

    end function qmckl_compute_ee_distance
    #+end_src

*** Test

    #+begin_src python :results output :exports none
import numpy as np

elec_1_w1 = np.array( [ -2.26995253563, -5.15737533569, -2.22940072417 ])
elec_2_w1 = np.array( [  3.51983380318, -1.08717381954, -1.19617708027 ])
elec_1_w2 = np.array( [ -2.34410619736, -3.20016115904, -1.53496759012 ])
elec_2_w2 = np.array( [  3.17996025085, -1.40260577202,  1.49473607540 ])

print ( "[0][0][0] : ", np.linalg.norm(elec_1_w1-elec_1_w1) )
print ( "[0][1][0] : ", np.linalg.norm(elec_1_w1-elec_2_w1) )
print ( "[1][0][0] : ", np.linalg.norm(elec_2_w1-elec_1_w1) )
print ( "[0][0][1] : ", np.linalg.norm(elec_1_w2-elec_1_w2) )
print ( "[0][1][1] : ", np.linalg.norm(elec_1_w2-elec_2_w2) )
print ( "[1][0][1] : ", np.linalg.norm(elec_2_w2-elec_1_w2) )
    #+end_src

    #+RESULTS:
    : [0][0][0] :  0.0
    : [0][1][0] :  7.152322512964209
    : [1][0][0] :  7.152322512964209
    : [0][0][1] :  0.0
    : [0][1][1] :  6.5517646321055665
    : [1][0][1] :  6.5517646321055665

     #+begin_src c :tangle (eval c_test)
assert(qmckl_electron_provided(context));


double ee_distance[walk_num * elec_num * elec_num];
rc = qmckl_get_electron_ee_distance(context, ee_distance);

// (e1,e2,w)
// (0,0,0) == 0.
assert(ee_distance[0] == 0.);

// (1,0,0) == (0,1,0)
assert(ee_distance[1] == ee_distance[elec_num]);

// value of (1,0,0)
// This is a test that will be compiled with Verificarlo

#ifdef HAVE_VERIFICARLO
vfc_probe(&probes, "qmckl_electron", "ee_distance[1]", ee_distance[1]);
#endif

assert(fabs(ee_distance[1]-7.152322512964209) < 1.e-12);

// (0,0,1) == 0.
assert(ee_distance[elec_num*elec_num] == 0.);

// (1,0,1) == (0,1,1)
assert(ee_distance[elec_num*elec_num+1] == ee_distance[elec_num*elec_num+elec_num]);

// value of (1,0,1)
assert(fabs(ee_distance[elec_num*elec_num+1]-6.5517646321055665) < 1.e-12);

     #+end_src

** Electron-nucleus distances

*** Get

    #+begin_src c :comments org :tangle (eval h_func) :noweb yes
qmckl_exit_code qmckl_get_electron_en_distance(qmckl_context context, double* distance);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_get_electron_en_distance(qmckl_context context, double* distance)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_exit_code rc;

  rc = qmckl_provide_en_distance(context);
  if (rc != QMCKL_SUCCESS) return rc;

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  size_t sze = ctx->electron.num * ctx->nucleus.num * ctx->electron.walk_num;
  memcpy(distance, ctx->electron.en_distance, sze * sizeof(double));

  return QMCKL_SUCCESS;
}
    #+end_src

*** Provide                                                        :noexport:

    #+begin_src c :comments org :tangle (eval h_private_func) :noweb yes :exports none
qmckl_exit_code qmckl_provide_en_distance(qmckl_context context);
    #+end_src

    #+begin_src c :comments org :tangle (eval c) :noweb yes  :exports none
qmckl_exit_code qmckl_provide_en_distance(qmckl_context context)
{

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return QMCKL_NULL_CONTEXT;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  if (!(ctx->nucleus.provided)) {
    return QMCKL_NOT_PROVIDED;
  }

  /* Compute if necessary */
  if (ctx->electron.coord_new_date > ctx->electron.en_distance_date) {

    /* Allocate array */
    if (ctx->electron.en_distance == NULL) {

      qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
      mem_info.size = ctx->electron.num * ctx->nucleus.num *
        ctx->electron.walk_num * sizeof(double);
      double* en_distance = (double*) qmckl_malloc(context, mem_info);

      if (en_distance == NULL) {
        return qmckl_failwith( context,
                               QMCKL_ALLOCATION_FAILED,
                               "qmckl_en_distance",
                               NULL);
      }
      ctx->electron.en_distance = en_distance;
    }

    qmckl_exit_code rc =
      qmckl_compute_en_distance(context,
                                ctx->electron.num,
                                ctx->nucleus.num,
                                ctx->electron.walk_num,
                                ctx->electron.coord_new,
                                ctx->nucleus.coord,
                                ctx->electron.en_distance);
    if (rc != QMCKL_SUCCESS) {
      return rc;
    }

    ctx->electron.en_distance_date = ctx->date;
  }

  return QMCKL_SUCCESS;
}
    #+end_src

*** Compute
   :PROPERTIES:
   :Name:     qmckl_compute_en_distance
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

    #+NAME: qmckl_en_distance_args
   | qmckl_context | context                                   | in  | Global state               |
   | int64_t       | elec_num                                  | in  | Number of electrons        |
   | int64_t       | nucl_num                                  | in  | Number of nuclei           |
   | int64_t       | walk_num                                  | in  | Number of walkers          |
   | double        | elec_coord[walk_num][3][elec_num]         | in  | Electron coordinates       |
   | double        | nucl_coord[3][elec_num]                   | in  | Nuclear coordinates        |
   | double        | en_distance[walk_num][nucl_num][elec_num] | out | Electron-nucleus distances |

    #+begin_src f90 :comments org :tangle (eval f) :noweb yes
integer function qmckl_compute_en_distance_f(context, elec_num, nucl_num, walk_num, elec_coord, nucl_coord, en_distance) &
     result(info)
  use qmckl
  implicit none
  integer(qmckl_context), intent(in)  :: context
  integer*8             , intent(in)  :: elec_num
  integer*8             , intent(in)  :: nucl_num
  integer*8             , intent(in)  :: walk_num
  double precision      , intent(in)  :: elec_coord(elec_num,3,walk_num)
  double precision      , intent(in)  :: nucl_coord(nucl_num,3)
  double precision      , intent(out) :: en_distance(elec_num,nucl_num,walk_num)

  integer*8 :: k

  info = QMCKL_SUCCESS

  if (context == QMCKL_NULL_CONTEXT) then
     info = QMCKL_INVALID_CONTEXT
     return
  endif

  if (elec_num <= 0) then
     info = QMCKL_INVALID_ARG_2
     return
  endif

  if (nucl_num <= 0) then
     info = QMCKL_INVALID_ARG_3
     return
  endif

  if (walk_num <= 0) then
     info = QMCKL_INVALID_ARG_4
     return
  endif

  do k=1,walk_num
     info = qmckl_distance(context, 'T', 'T', elec_num, nucl_num, &
          elec_coord(1,1,k), elec_num, &
          nucl_coord, nucl_num, &
          en_distance(1,1,k), elec_num)
     if (info /= QMCKL_SUCCESS) then
        exit
     endif
  end do

end function qmckl_compute_en_distance_f
    #+end_src

    #+begin_src c :tangle (eval h_private_func) :comments org :exports none
qmckl_exit_code qmckl_compute_en_distance (
          const qmckl_context context,
          const int64_t elec_num,
          const int64_t nucl_num,
          const int64_t walk_num,
          const double* elec_coord,
          const double* nucl_coord,
          double* const en_distance );
    #+end_src

    #+CALL: generate_c_interface(table=qmckl_en_distance_args,rettyp=get_value("CRetType"),fname=get_value("Name"))

    #+RESULTS:
    #+begin_src f90 :tangle (eval f) :comments org :exports none
    integer(c_int32_t) function qmckl_compute_en_distance &
        (context, elec_num, nucl_num, walk_num, elec_coord, nucl_coord, en_distance) &
        bind(C) result(info)

      use, intrinsic :: iso_c_binding
      implicit none

      integer (c_int64_t) , intent(in)  , value :: context
      integer (c_int64_t) , intent(in)  , value :: elec_num
      integer (c_int64_t) , intent(in)  , value :: nucl_num
      integer (c_int64_t) , intent(in)  , value :: walk_num
      real    (c_double ) , intent(in)          :: elec_coord(elec_num,3,walk_num)
      real    (c_double ) , intent(in)          :: nucl_coord(elec_num,3)
      real    (c_double ) , intent(out)         :: en_distance(elec_num,nucl_num,walk_num)

      integer(c_int32_t), external :: qmckl_compute_en_distance_f
      info = qmckl_compute_en_distance_f &
             (context, elec_num, nucl_num, walk_num, elec_coord, nucl_coord, en_distance)

    end function qmckl_compute_en_distance
    #+end_src

*** Test

    #+begin_src python :results output :exports none
import numpy as np

elec_1_w1 = np.array( [ -2.26995253563, -5.15737533569, -2.22940072417 ])
elec_2_w1 = np.array( [  3.51983380318, -1.08717381954, -1.19617708027 ])
elec_1_w2 = np.array( [ -2.34410619736, -3.20016115904, -1.53496759012 ])
elec_2_w2 = np.array( [  3.17996025085, -1.40260577202,  1.49473607540 ])
nucl_1    = np.array( [ 1.096243353458458e+00, 8.907054016973815e-01, 7.777092280258892e-01 ] )
nucl_2    = np.array( [ 1.168459237342663e+00, 1.125660720053393e+00, 2.833370314829343e+00 ] )

print ( "[0][0][0] : ", np.linalg.norm(elec_1_w1-nucl_1) )
print ( "[0][1][0] : ", np.linalg.norm(elec_1_w1-nucl_2) )
print ( "[0][0][1] : ", np.linalg.norm(elec_2_w1-nucl_1) )
print ( "[1][0][0] : ", np.linalg.norm(elec_1_w2-nucl_1) )
print ( "[1][1][0] : ", np.linalg.norm(elec_1_w2-nucl_2) )
print ( "[1][0][1] : ", np.linalg.norm(elec_2_w2-nucl_1) )
    #+end_src

    #+RESULTS:
    : [0][0][0] :  7.546738741619978
    : [0][1][0] :  8.77102435246984
    : [0][0][1] :  3.698922010513608
    : [1][0][0] :  5.824059436060509
    : [1][1][0] :  7.080482110317645
    : [1][0][1] :  3.1804527583077356

     #+begin_src c :tangle (eval c_test)

assert(!qmckl_nucleus_provided(context));
assert(qmckl_electron_provided(context));

rc = qmckl_set_nucleus_num (context, nucl_num);
assert(rc == QMCKL_SUCCESS);

rc = qmckl_set_nucleus_charge (context, charge);
assert (rc == QMCKL_SUCCESS);

rc = qmckl_set_nucleus_coord (context, 'T', nucl_coord);
assert (rc == QMCKL_SUCCESS);

assert(qmckl_nucleus_provided(context));

double en_distance[walk_num][nucl_num][elec_num];

rc = qmckl_get_electron_en_distance(context, &(en_distance[0][0][0]));
assert (rc == QMCKL_SUCCESS);

// (e,n,w) in Fortran notation
// (1,1,1)
assert(fabs(en_distance[0][0][0] - 7.546738741619978) < 1.e-12);

// (1,2,1)
assert(fabs(en_distance[0][1][0] - 8.77102435246984) < 1.e-12);

// (2,1,1)
assert(fabs(en_distance[0][0][1] - 3.698922010513608) < 1.e-12);

// (1,1,2)
assert(fabs(en_distance[1][0][0] - 5.824059436060509) < 1.e-12);

// (1,2,2)
assert(fabs(en_distance[1][1][0] - 7.080482110317645) < 1.e-12);

// (2,1,2)
assert(fabs(en_distance[1][0][1] - 3.1804527583077356) < 1.e-12);

     #+end_src

* End of files                                                     :noexport:

  #+begin_src c :tangle (eval h_private_type)
#endif
  #+end_src

*** Test
  #+begin_src c :tangle (eval c_test)
  if (qmckl_context_destroy(context) != QMCKL_SUCCESS)
    return QMCKL_FAILURE;
  return 0;
}
  #+end_src

**✸ Compute file names
    #+begin_src emacs-lisp
; The following is required to compute the file names

(setq pwd (file-name-directory buffer-file-name))
(setq name (file-name-nondirectory (substring buffer-file-name 0 -4)))
(setq f  (concat pwd name "_f.f90"))
(setq fh (concat pwd name "_fh.f90"))
(setq c  (concat pwd name ".c"))
(setq h  (concat name ".h"))
(setq h_private  (concat name "_private.h"))
(setq c_test  (concat pwd "test_" name ".c"))
(setq f_test  (concat pwd "test_" name "_f.f90"))

; Minted
(require 'ox-latex)
(setq org-latex-listings 'minted)
(add-to-list 'org-latex-packages-alist '("" "listings"))
(add-to-list 'org-latex-packages-alist '("" "color"))

    #+end_src

    #+RESULTS:
    |   | color    |
    |   | listings |


# -*- mode: org -*-
# vim: syntax=c


